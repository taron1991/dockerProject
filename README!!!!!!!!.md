Виртуализация: Представьте, что у вас есть несколько отдельных компьютеров внутри вашего компьютера. Каждый из этих виртуальных компьютеров может работать независимо от других, имеет свою операционную систему и ресурсы. Виртуализация создает полные виртуальные копии физических компьютеров.
Контейнеризация: Теперь представьте, что у вас есть коробка, в которой упаковано приложение со всеми его зависимостями. Эта коробка (контейнер) работает на вашем компьютере, используя общие ресурсы с другими контейнерами. Контейнеризация позволяет запускать приложения в изолированных средах, но без полной виртуализации операционной системы.

Docker контейнеры работают на базе операционной системы Linux. 

FROM openjdk:17-alpine
#копируем целиком(там много файлов) папку из локалки внутрь контейнера
COPY /target /target
#запускаем джарник изнутри контейнера,не можем просто написать /target т.к внутри много папок а пишем конкретно jar
CMD ["java","-jar","/target/DeleteDocker-1.0-SNAPSHOT.jar"]

#RUN npm install
#это установка(скачивание) а также ЗАПУСК каких-то файлов или программ во время сборки образа!! а CMD запускает команды при создании уже контейнра!!!!
#Например хотим приготовить пирог с яблоками
# From - основное тесто
# RUN - нарезать яблоко
# ADD - Основное различие между(COPY) ними заключается в том, что команда "ADD" также поддерживает автоматическую распаковку файлов
# WORKDIR - раб папка

добавь зависимости для указания местоположения майн класса

 <build>
        <plugins>
            <plugin>
                <!-- Build an executable JAR -->
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <classpathPrefix>lib/</classpathPrefix>
                            <mainClass>orgs.Hello</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>


 !!!!!!!!!!!!!
 любые запросы, направленные на порт 5432 на вашем хосте, будут перенаправлены на порт 5432 внутри контейнера, где работает база данных PostgreSQL. Это обеспечивает внешний доступ к базе данных в контейнере через указанный порт хоста.
НО В SPRING BOOT ПРИЛОЖЕНИИ перебрасывание портов необязательно потому что когда мы делаем запрос с локалки он пернхватывается сервисом из контейнера (app) и он дальше сам взаимодействует с базой данных КОНТЕЙНЕРА! по имени т.к образует единое сетевое пространство!

ЗАПУСК!!
docker build -t app .
docker run app

ЗАПУСК COMPOSE!
docker-compose build
docker-compose up

#docker build -t app . построй образ этот и ищи его (докерфайл) в текущей директории
#docker run -p 8080:8080 app
#!!!!!!!Port mapping (отображение портов) используется для установления связи между локальным приложением
#на вашем компьютере и приложением, запущенным внутри контейнера Docker.
#Вот представь у нас есть spring rest приложение и есть метод save(request body) вот вопрос а как мне передать
#обьект request body? тоесть есть контейнер докер и все!запросы я буду делать сам!!!!!!!на локальном компьютере!!
#так а как сделать так чтобы мои запросы с локалки шли в контейнер(spring rest) и они обрабатывались??
#создать port mapping  8080:8081(внутрь) ОТНЫНЕ мои запросы с локалки(postman) пойдут на порт 8081 внутри контейнера
#без этого наша локалка не поймет куда отправлять запросы так как не знает порт контейнера
#Процесс выглядит примерно так:
#Вы отправляете HTTP POST запрос из Postman с данными пользователя на адрес вашего Spring Boot приложения (например, http://localhost:8080/users) с локального компьютера.
#Запущенный контейнер Docker, в котором работает ваше Spring Boot приложение, прослушивает порт 8080 (или другой порт, который вы настроили) и получает этот HTTP запрос.
#Spring Boot приложение внутри контейнера обрабатывает запрос, извлекает данные пользователя из request body и выполняет соответствующие действия, например, сохранение пользователя в базе данных.

#Команда COPY в Docker можно сравнить с процессом копирования
#файлов с USB-накопителя на ваш компьютер. Вы берете файлы с USB-накопителя и копируете их на жесткий диск компьютера,
#чтобы они стали доступны для использования на вашем компьютере.


#с помощью команды CMD указывается команда, которая будет выполнена при запуске контейнера.
#В данном случае, при запуске контейнера будет
#выполнена команда "java -jar /target/DeleteDocker-1.0-SNAPSHOT.jar"
# dockerProject
